{"ast":null,"code":"import { Color } from \"../components/ChessBoard\";\nconst boardFiles = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"];\nconst boardRanks = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"];\n\n//defining outside gameaRef class so i can use within class\nconst squareHasPiece = function (file, rank, currentBoard) {\n  let hasPiece = false;\n  currentBoard.forEach(piece => {\n    let pieceRank = piece.rank;\n    let pieceFile = piece.file; //console.log(\"position saught: \" + file + rank + \"position found: \" + piece.rank + piece.file);\n\n    if (rank === pieceRank && pieceFile === file) {\n      hasPiece = true;\n    }\n  });\n  return hasPiece;\n};\n\nconst getPieceColor = function (file, rank, currentBoard) {\n  let returnedColor = 0;\n  currentBoard.forEach(piece => {\n    let color = piece.color;\n    let pieceRank = piece.rank;\n    let pieceFile = piece.file; //console.log(\"position saught: \" + file + rank + \"position found: \" + piece.rank + piece.file);\n\n    if (rank === pieceRank && pieceFile === file) {\n      returnedColor = color;\n    }\n  });\n  return returnedColor;\n};\n\nclass gameRef {\n  squareHasPiece(file, rank, currentBoard) {\n    let hasPiece = false;\n    currentBoard.forEach(piece => {\n      let pieceRank = piece.rank;\n      let pieceFile = piece.file; //console.log(\"position saught: \" + file + rank + \"position found: \" + piece.rank + piece.file);\n\n      if (rank === pieceRank && pieceFile === file) {\n        hasPiece = true;\n      }\n    });\n    return hasPiece;\n  }\n\n  listOfSquareshavePiece(squares) {}\n\n  kingInCheck(color, currentBoard) {\n    var inCheck = false;\n    var king = currentBoard.find(piece => piece.color === color && piece.type === 5); //1st find location of king\n\n    if (king) {\n      var kingSquare = king.file + king.rank;\n    } //check if any of the pieces on the opposite team can reach that square\n\n\n    currentBoard.forEach(piece => {\n      if (piece.color !== color && this.isValidMove(piece.file + piece.rank, kingSquare, piece.type, piece.color, currentBoard)) {\n        inCheck = true;\n        console.log(color + \" is in check!\");\n      }\n    });\n    return inCheck;\n  }\n\n  isValidMove(prevSquare, newSquare, type, color, currentBoard) {\n    var oldY = parseInt(prevSquare[1]);\n    var newY = parseInt(newSquare[1]);\n    var prevFile = prevSquare[0];\n    var newFile = newSquare[0];\n    var oldX = boardFiles.indexOf(prevFile);\n    var newX = boardFiles.indexOf(newFile);\n    var enemyOnSquare = false;\n    var friendlyOnSquare = false;\n\n    if (squareHasPiece(newFile, `${newY}`, currentBoard) && getPieceColor(newFile, `${newY}`, currentBoard) !== color) {\n      enemyOnSquare = true;\n    }\n\n    ;\n\n    if (squareHasPiece(newFile, `${newY}`, currentBoard) && getPieceColor(newFile, `${newY}`, currentBoard) === color) {\n      friendlyOnSquare = true;\n    }\n\n    ; //console.log(`${colors[color]} ${pieceNames[type]} moved from ${prevSquare} to ${newSquare}`);\n    //function to whether white pawn can move. If it is on 1st rank it can move forward 2\n\n    function whitePawnValidity() {\n      if (prevFile === newFile && (newY - oldY === 1 || newY - oldY === 2 && oldY === 2)) {\n        return squareHasPiece(newFile, `${newY}`, currentBoard) ? false : true;\n      } //take a piece movement\n      else if (color === Color.WHITE && Math.abs(oldX - newX) === 1 && newY - oldY === 1 && enemyOnSquare) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function blackPawnValidity() {\n      if (prevFile === newFile && (oldY - newY === 1 || oldY - newY === 2 && oldY === 7)) {\n        return squareHasPiece(newFile, `${newY}`, currentBoard) ? false : true;\n      } //take a piece movement\n      else if (Math.abs(newX - oldX) === 1 && oldY - newY === 1 && enemyOnSquare) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function RookValidity() {\n      var inBetweenSquares = [];\n      let movesValid = true;\n\n      if (newFile === prevFile && newY !== oldY || newFile !== prevFile && newY === oldY) {\n        //if rooks moving right or left. check the squares in between and make sure they don't have a piece\n        // if any piece has a square return false\n        if (newX > oldX || newX < oldX) {\n          let inBetweenFiles = [];\n          inBetweenFiles = newX > oldX ? boardFiles.slice(oldX + 1, newX) : boardFiles.slice(newX + 1, oldX);\n          inBetweenFiles.forEach(file => {\n            inBetweenSquares.push(file + oldY);\n          });\n        } else {\n          let inBetweenRanks = [];\n          inBetweenRanks = newY > oldY ? boardRanks.slice(oldY, newY - 1) : boardRanks.slice(newY, oldY - 1);\n          inBetweenRanks.forEach(rank => {\n            inBetweenSquares.push(prevFile + rank);\n          }); // console.log(\"inbetween squares: \" + inBetweenSquares);\n          // console.log(\"oldY: \" + oldY + \" newY: \" + newY); \n          //console.log(\"inbeteween Ranks: \" + inBetweenRanks);\n        }\n\n        if (inBetweenSquares !== null) {\n          inBetweenSquares.forEach(piece => {\n            if (squareHasPiece(piece[0], piece[1], currentBoard)) {\n              movesValid = false;\n            }\n          }); //returning false because there is a piece in between where the rook is going to and its current square\n        }\n\n        return movesValid;\n      } else {\n        return false;\n      }\n    }\n\n    function BishopValidity() {\n      let movesValid = true;\n      let inBetweenSquares = [];\n\n      if (newY - oldY === newX - oldX || Math.abs(oldY - newY) === Math.abs(oldX - newX)) {\n        //creating array of ranks/ files inbetween old square and new square then combining into list of\n        //squares in between old position and new. THen will check those for a piece\n        let inBetweenRanks = [];\n        let inBetweenFiles = [];\n\n        if (newY > oldY && newX > oldX) {\n          //bishop moves up to the right\n          inBetweenFiles = boardFiles.slice(oldX + 1, newX);\n          inBetweenRanks = boardRanks.slice(oldY, newY);\n        } else if (newY > oldY && newX < oldX) {\n          //bishop moves up to the left\n          inBetweenFiles = boardFiles.slice(newX + 1, oldX); //reversing because it is going down\n\n          inBetweenFiles = inBetweenFiles.reverse();\n          inBetweenRanks = boardRanks.slice(oldY, newY);\n        } else if (newY < oldY && newX > oldX) {\n          //bishop moves down right\n          inBetweenFiles = boardFiles.slice(oldX + 1, newX);\n          inBetweenRanks = boardRanks.slice(newY - 1, oldY - 1); //reversing the order because it is going down\n\n          inBetweenRanks = inBetweenRanks.reverse();\n        } else {\n          inBetweenFiles = boardFiles.slice(newX + 1, oldX);\n          inBetweenRanks = boardRanks.slice(newY, oldY - 1);\n        } // }else{\n        //     //bishop moves downLeft\n        //     console.log(\"bishop moves down right\");\n        //     inBetweenFiles=boardFiles.slice(oldX+1, newX);\n        //     inBetweenRanks=boardRanks.slice(newY-1, oldY-1);\n        //     inBetweenFiles=inBetweenFiles.reverse();\n        //     inBetweenRanks=boardRanks.slice(oldY, newY);\n        // }\n\n\n        for (var i = 0; i < inBetweenFiles.length; i++) {\n          inBetweenSquares.push(inBetweenFiles[i] + inBetweenRanks[i]);\n        }\n\n        if (inBetweenSquares !== null) {\n          inBetweenSquares.forEach(piece => {\n            if (squareHasPiece(piece[0], piece[1], currentBoard)) {\n              movesValid = false;\n            }\n          }); //returning false because there is a piece in between where the rook is going to and its current square\n        }\n      } else {\n        movesValid = false;\n      }\n\n      return movesValid;\n    }\n\n    function KnightValidity() {\n      let movesValid = true;\n\n      if ((Math.abs(newX - oldX) === 1 && Math.abs(newY - oldY) === 2 || Math.abs(newX - oldX) === 2 && Math.abs(newY - oldY) === 1) === false) {\n        movesValid = false;\n      }\n\n      return movesValid;\n    }\n\n    function kingValidity() {\n      //castling \n      if (color === 0 && prevSquare === \"e1\" && newSquare === \"g1\") {\n        if (squareHasPiece('f', '1', currentBoard) || squareHasPiece('g', '1', currentBoard)) {\n          return false;\n        } else {\n          if (squareHasPiece('h', \"1\", currentBoard)) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      } else if (color === 0 && prevSquare === \"e1\" && newSquare === \"c1\") {\n        if (squareHasPiece('d', '1', currentBoard) || squareHasPiece('c', '1', currentBoard) || squareHasPiece('b', '1', currentBoard)) {\n          return false;\n        } else {\n          if (squareHasPiece('a', \"1\", currentBoard)) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      } else if (color === 1 && prevSquare === \"e8\" && newSquare === \"g8\") {\n        if (squareHasPiece('f', '8', currentBoard) || squareHasPiece('g', '8', currentBoard)) {\n          return false;\n        } else {\n          if (squareHasPiece('h', \"8\", currentBoard)) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      } else if (color === 1 && prevSquare === \"e8\" && newSquare === \"c8\") {\n        if (squareHasPiece('d', '8', currentBoard) || squareHasPiece('c', '8', currentBoard) || squareHasPiece('b', '8', currentBoard)) {\n          return false;\n        } else {\n          if (squareHasPiece('a', \"8\", currentBoard)) {\n            return true;\n          } else {\n            return false;\n          }\n        } //non castling just moving one square away\n\n      } else if (Math.abs(oldX - newX) === 1 && oldY === newY || Math.abs(oldY - newY) === 1 && oldX === newX || Math.abs(oldX - newX) === 1 && Math.abs(oldY - newY) === 1) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    if (friendlyOnSquare) {\n      console.log(\"friend on square! don't take him\");\n      return false;\n    } else {\n      if (type === 0) {\n        return color ? blackPawnValidity() : whitePawnValidity();\n      } else if (type === 1) {\n        return KnightValidity();\n      } else if (type === 2) {\n        return BishopValidity();\n      } else if (type === 3) {\n        return RookValidity();\n      } else if (type === 4) {\n        return RookValidity() || BishopValidity();\n      } else if (type === 5) {\n        return kingValidity();\n      } else {\n        return false;\n      }\n    }\n  }\n\n}\n\nexport default gameRef;","map":{"version":3,"sources":["C:/Users/acalo/Desktop/devProjects/ChessFrontDeploy/src/game/legalmove.ts"],"names":["Color","boardFiles","boardRanks","squareHasPiece","file","rank","currentBoard","hasPiece","forEach","piece","pieceRank","pieceFile","getPieceColor","returnedColor","color","gameRef","listOfSquareshavePiece","squares","kingInCheck","inCheck","king","find","type","kingSquare","isValidMove","console","log","prevSquare","newSquare","oldY","parseInt","newY","prevFile","newFile","oldX","indexOf","newX","enemyOnSquare","friendlyOnSquare","whitePawnValidity","WHITE","Math","abs","blackPawnValidity","RookValidity","inBetweenSquares","movesValid","inBetweenFiles","slice","push","inBetweenRanks","BishopValidity","reverse","i","length","KnightValidity","kingValidity"],"mappings":"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","sourcesContent":["import  {pieceType, Color}  from \"../components/ChessBoard\";\r\n\r\nconst boardFiles = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"];\r\nconst boardRanks = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"];\r\n\r\ninterface Piece{\r\n    image: string\r\n    rank: string\r\n    file: string\r\n    type: pieceType\r\n    color: Color\r\n}\r\n//defining outside gameaRef class so i can use within class\r\nconst squareHasPiece = function( file: string, rank: string, currentBoard: Piece[]){\r\n    let hasPiece = false;\r\n    currentBoard.forEach(piece =>{\r\n        let pieceRank = piece.rank;\r\n        let pieceFile = piece.file;\r\n        //console.log(\"position saught: \" + file + rank + \"position found: \" + piece.rank + piece.file);\r\n        if(rank===pieceRank && pieceFile===file){\r\n            hasPiece=true;\r\n        }\r\n    })\r\n    return hasPiece;\r\n}\r\n\r\nconst getPieceColor = function( file: string, rank: string, currentBoard: Piece[]){\r\n    let returnedColor = 0;\r\n    currentBoard.forEach(piece => {\r\n        let color = piece.color;\r\n        let pieceRank = piece.rank;\r\n        let pieceFile = piece.file;\r\n        //console.log(\"position saught: \" + file + rank + \"position found: \" + piece.rank + piece.file);\r\n        if(rank===pieceRank && pieceFile===file){\r\n            returnedColor=color;\r\n        }\r\n    })\r\n    return returnedColor;\r\n\r\n}\r\nclass gameRef {\r\n    squareHasPiece(file: string, rank: string, currentBoard: Piece[]){\r\n        let hasPiece = false;\r\n        currentBoard.forEach(piece =>{\r\n            let pieceRank = piece.rank;\r\n            let pieceFile = piece.file;\r\n            //console.log(\"position saught: \" + file + rank + \"position found: \" + piece.rank + piece.file);\r\n            if(rank===pieceRank && pieceFile===file){\r\n                hasPiece=true;\r\n            }\r\n        })\r\n        return hasPiece;\r\n    }\r\n    listOfSquareshavePiece(squares: string[], ){\r\n\r\n    }\r\n    \r\n    kingInCheck(color: Color, currentBoard: Piece[]){\r\n        var inCheck = false;\r\n        var king = currentBoard.find(piece=>piece.color===color && piece.type===5);\r\n        //1st find location of king\r\n        if(king){\r\n            var kingSquare = king.file + king.rank\r\n        }\r\n        //check if any of the pieces on the opposite team can reach that square\r\n        currentBoard.forEach(piece=>{\r\n            if(piece.color!==color && this.isValidMove(piece.file+piece.rank, kingSquare, piece.type, piece.color, currentBoard)){\r\n                inCheck=true;\r\n                console.log(color + \" is in check!\");\r\n            }\r\n        })\r\n        return (inCheck);\r\n    }\r\n\r\n    isValidMove(prevSquare: any, newSquare: any, type: pieceType, color: Color, currentBoard: Piece[]){\r\n        var oldY = parseInt(prevSquare[1]);\r\n        var newY = parseInt(newSquare[1]);\r\n        var prevFile = prevSquare[0]\r\n        var newFile = newSquare[0]\r\n        var oldX = boardFiles.indexOf(prevFile);\r\n        var newX = boardFiles.indexOf(newFile);\r\n        var enemyOnSquare: boolean = false;\r\n        var friendlyOnSquare: boolean = false;\r\n\r\n\r\n        if(squareHasPiece(newFile, `${newY}`, currentBoard) && (getPieceColor(newFile, `${newY}`, currentBoard)!==color)){\r\n            enemyOnSquare=true;\r\n        };\r\n        if(squareHasPiece(newFile, `${newY}`, currentBoard) && (getPieceColor(newFile, `${newY}`, currentBoard)===color)){\r\n            friendlyOnSquare=true;\r\n        };\r\n\r\n        //console.log(`${colors[color]} ${pieceNames[type]} moved from ${prevSquare} to ${newSquare}`);\r\n        //function to whether white pawn can move. If it is on 1st rank it can move forward 2\r\n        function whitePawnValidity(){\r\n            if(prevFile===newFile && (newY-oldY===1 || (newY-oldY===2 && oldY===2))){\r\n                return squareHasPiece(newFile, `${newY}`, currentBoard) ? false: true;\r\n            }//take a piece movement\r\n            else if(color===Color.WHITE && (Math.abs(oldX-newX)===1) && newY-oldY===1 && enemyOnSquare){\r\n                return(true);\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        function blackPawnValidity(){\r\n            if(prevFile===newFile && (oldY-newY===1 || (oldY-newY===2 && oldY===7))){\r\n                return squareHasPiece(newFile, `${newY}`, currentBoard) ? false: true;\r\n            }//take a piece movement\r\n            else if((Math.abs(newX-oldX)===1) && oldY - newY===1 && enemyOnSquare){\r\n                return(true);\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n\r\n        }\r\n        function RookValidity(){\r\n            var inBetweenSquares: string[] = [];\r\n            let movesValid = true;\r\n            if((newFile===prevFile && newY!==oldY) || (newFile!==prevFile && newY===oldY)){\r\n                //if rooks moving right or left. check the squares in between and make sure they don't have a piece\r\n                // if any piece has a square return false\r\n                if(newX>oldX || newX<oldX){\r\n                    let inBetweenFiles: string[] = [];\r\n                    inBetweenFiles= newX>oldX ? boardFiles.slice(oldX+1, newX): boardFiles.slice(newX+1, oldX)\r\n                    inBetweenFiles.forEach(file =>{\r\n                        inBetweenSquares.push(file + oldY);\r\n                    })\r\n                }else{\r\n                    let inBetweenRanks: string[] = [];\r\n                    inBetweenRanks = newY>oldY ? boardRanks.slice(oldY, newY-1): boardRanks.slice(newY, oldY-1);\r\n                    inBetweenRanks.forEach(rank => {\r\n                        inBetweenSquares.push(prevFile + rank);\r\n                    })\r\n                    // console.log(\"inbetween squares: \" + inBetweenSquares);\r\n                    // console.log(\"oldY: \" + oldY + \" newY: \" + newY); \r\n                    //console.log(\"inbeteween Ranks: \" + inBetweenRanks);\r\n                }\r\n                if(inBetweenSquares!==null){\r\n                    inBetweenSquares.forEach(piece => {\r\n                        if(squareHasPiece(piece[0], piece[1], currentBoard)){\r\n                            movesValid=false;\r\n                        }\r\n                    })\r\n                    //returning false because there is a piece in between where the rook is going to and its current square\r\n                    }\r\n\r\n                    return movesValid;\r\n            }else{\r\n                return false;\r\n            }\r\n            \r\n        }\r\n        function BishopValidity(){\r\n            let movesValid=true;\r\n            let inBetweenSquares: string[] = [];\r\n            if((newY-oldY===newX-oldX) || (Math.abs(oldY-newY)===Math.abs(oldX-newX))){\r\n                //creating array of ranks/ files inbetween old square and new square then combining into list of\r\n                //squares in between old position and new. THen will check those for a piece\r\n                let inBetweenRanks: string[]=[]\r\n                let inBetweenFiles: string[]=[]\r\n                if(newY>oldY && newX>oldX){\r\n                    //bishop moves up to the right\r\n                    inBetweenFiles=boardFiles.slice(oldX+1, newX);\r\n                    inBetweenRanks=boardRanks.slice(oldY, newY);\r\n                }else if(newY>oldY && newX<oldX){\r\n                    //bishop moves up to the left\r\n                    inBetweenFiles=boardFiles.slice(newX+1, oldX);\r\n                    //reversing because it is going down\r\n                    inBetweenFiles=inBetweenFiles.reverse();\r\n                    inBetweenRanks=boardRanks.slice(oldY, newY); \r\n                }else if(newY<oldY && newX>oldX){\r\n                    //bishop moves down right\r\n                    inBetweenFiles=boardFiles.slice(oldX+1, newX);\r\n                    inBetweenRanks=boardRanks.slice(newY-1, oldY-1);\r\n                    //reversing the order because it is going down\r\n                    inBetweenRanks=inBetweenRanks.reverse();\r\n                }else{\r\n                    inBetweenFiles=boardFiles.slice(newX+1, oldX);\r\n                    inBetweenRanks=boardRanks.slice(newY, oldY-1);\r\n\r\n                }\r\n                    // }else{\r\n                //     //bishop moves downLeft\r\n                //     console.log(\"bishop moves down right\");\r\n\r\n                //     inBetweenFiles=boardFiles.slice(oldX+1, newX);\r\n                //     inBetweenRanks=boardRanks.slice(newY-1, oldY-1);\r\n                //     inBetweenFiles=inBetweenFiles.reverse();\r\n                //     inBetweenRanks=boardRanks.slice(oldY, newY);\r\n                // }\r\n                for(var i = 0; i<inBetweenFiles.length; i++){\r\n                    inBetweenSquares.push(inBetweenFiles[i] + inBetweenRanks[i]);\r\n                }\r\n                if(inBetweenSquares!==null){\r\n                    inBetweenSquares.forEach(piece => {\r\n                        if(squareHasPiece(piece[0], piece[1], currentBoard)){\r\n                            movesValid=false;\r\n                            \r\n                        }\r\n                    })\r\n                \r\n                    //returning false because there is a piece in between where the rook is going to and its current square\r\n                    }\r\n            }else{\r\n                movesValid= false;\r\n            }\r\n            return movesValid;\r\n        }\r\n        function KnightValidity(){\r\n            let movesValid=true;\r\n            if((((Math.abs(newX-oldX)===1)&& (Math.abs(newY-oldY)===2)) ||((Math.abs(newX-oldX)===2)&& (Math.abs(newY-oldY)===1)))===false ){\r\n                movesValid=false;\r\n            }\r\n            return movesValid;\r\n        }\r\n        function kingValidity(){\r\n            //castling \r\n            if(color===0 && prevSquare===\"e1\" && newSquare===\"g1\"){\r\n                if(squareHasPiece('f', '1', currentBoard) || squareHasPiece('g','1',currentBoard)){\r\n                    return false;\r\n                }else{\r\n                    if(squareHasPiece('h',\"1\", currentBoard)){\r\n                        return true;\r\n                    }else{\r\n                        return false;\r\n                    }\r\n                }\r\n            }else if(color===0 && prevSquare===\"e1\" && newSquare===\"c1\"){\r\n                if(squareHasPiece('d', '1', currentBoard) || squareHasPiece('c','1',currentBoard) || squareHasPiece('b','1',currentBoard)){\r\n                    return false;\r\n                }else{\r\n                    if(squareHasPiece('a',\"1\", currentBoard)){\r\n                        return true;\r\n                    }else{\r\n                        return false;\r\n                    }\r\n                }\r\n            }else if(color===1 && prevSquare===\"e8\" && newSquare===\"g8\"){\r\n                if(squareHasPiece('f', '8', currentBoard) || squareHasPiece('g','8',currentBoard)){\r\n                    return false;\r\n                }else{\r\n                    if(squareHasPiece('h',\"8\", currentBoard)){\r\n                        return true;\r\n                    }else{\r\n                        return false;\r\n                    }\r\n                }\r\n            }else if(color===1 && prevSquare===\"e8\" && newSquare===\"c8\"){\r\n                if(squareHasPiece('d', '8', currentBoard) || squareHasPiece('c','8',currentBoard) || squareHasPiece('b','8',currentBoard)){\r\n                    return false;\r\n                }else{\r\n                    if(squareHasPiece('a',\"8\", currentBoard)){\r\n                        return true;\r\n                    }else{\r\n                        return false;\r\n                    }\r\n                }\r\n            //non castling just moving one square away\r\n            }else if((Math.abs(oldX-newX)===1&& oldY===newY) || (Math.abs(oldY-newY)===1&& oldX===newX) || (Math.abs(oldX-newX)===1&&Math.abs(oldY-newY)===1)){\r\n                return true;\r\n            }else{\r\n                return false;\r\n            }\r\n        }\r\n    if(friendlyOnSquare){\r\n        console.log(\"friend on square! don't take him\");\r\n        return false;\r\n    }else{\r\n        if(type===0){\r\n            return(color ? blackPawnValidity(): whitePawnValidity());\r\n        }else if(type===1){\r\n            return(KnightValidity());\r\n        }else if (type===2){\r\n            return(BishopValidity());\r\n        }else if (type===3){\r\n            return(RookValidity());\r\n        }else if (type===4){\r\n            return((RookValidity() || BishopValidity()));\r\n        }else if(type===5){\r\n            return(kingValidity());\r\n        }\r\n        else{\r\n            return(false);\r\n        }\r\n\r\n    }    \r\n}\r\n}\r\n\r\nexport default gameRef;"]},"metadata":{},"sourceType":"module"}