[{"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\index.tsx":"1","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\App.tsx":"2","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\game\\moves.ts":"3","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\SideBar.tsx":"4","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Header.tsx":"5","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\HomePage.tsx":"6","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\GamePage.tsx":"7","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\PlayerImg.tsx":"8","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\ChessBoard.tsx":"9","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\MovesDisplay.tsx":"10","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Description.tsx":"11","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\game\\legalmove.ts":"12","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\square.tsx":"13","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Engine.tsx":"14","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Accordion.jsx":"15","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Modal.tsx":"16","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\MovingImage.js":"17"},{"size":156,"mtime":1637862760105,"results":"18","hashOfConfig":"19"},{"size":9527,"mtime":1641358000393,"results":"20","hashOfConfig":"19"},{"size":11320,"mtime":1641357828039,"results":"21","hashOfConfig":"19"},{"size":2779,"mtime":1641357278981,"results":"22","hashOfConfig":"19"},{"size":217,"mtime":1628696129475,"results":"23","hashOfConfig":"19"},{"size":6831,"mtime":1641357949605,"results":"24","hashOfConfig":"19"},{"size":1686,"mtime":1637862826896,"results":"25","hashOfConfig":"19"},{"size":1217,"mtime":1630872574627,"results":"26","hashOfConfig":"19"},{"size":25947,"mtime":1642129172041,"results":"27","hashOfConfig":"19"},{"size":3982,"mtime":1642478274547,"results":"28","hashOfConfig":"19"},{"size":353,"mtime":1628613378432,"results":"29","hashOfConfig":"19"},{"size":12472,"mtime":1637944456519,"results":"30","hashOfConfig":"19"},{"size":1815,"mtime":1632876822658,"results":"31","hashOfConfig":"19"},{"size":3354,"mtime":1631818729292,"results":"32","hashOfConfig":"19"},{"size":1465,"mtime":1628621050540,"results":"33","hashOfConfig":"19"},{"size":497,"mtime":1637946730794,"results":"34","hashOfConfig":"19"},{"size":2422,"mtime":1638848963893,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"1rg4mvv",{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"49","messages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"51","messages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"53","messages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"38"},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"60","messages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\index.tsx",[],["73","74"],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\App.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\game\\moves.ts",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\SideBar.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Header.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\HomePage.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\GamePage.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\PlayerImg.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\ChessBoard.tsx",["75","76","77","78","79","80","81","82","83","84","85","86","87","88"],"import React, {useState, useEffect, useRef} from \"react\";\r\nimport { Modal} from 'react-bootstrap';\r\nimport GameModal from \"./Modal\";\r\nimport Square from \"./square\";\r\nimport gameRef from \"../game/legalmove\";\r\nimport MovingImage from \"./MovingImage\";\r\n\r\nenum pieceType {\r\n    PAWN,\r\n    KNIGHT,\r\n    BISHOP,\r\n    ROOK,\r\n    QUEEN,\r\n    KING    \r\n}\r\n\r\nenum Color{\r\n    WHITE,\r\n    BLACK\r\n}\r\n\r\ninterface Piece{\r\n    image: string\r\n    rank: string\r\n    file: string\r\n    type: pieceType\r\n    color: Color\r\n}\r\n\r\ninterface TakenPiece{\r\n    piece: any\r\n    moveNumber: number\r\n}\r\n\r\nlet gameBeginAudio = new Audio(\"/sound/start.mp3\");\r\nlet moveSound = new Audio('/sound/move_sound.mp3')\r\n\r\nconst verticalAxis = [\"8\",\"7\",\"6\",\"5\",\"4\", \"3\",\"2\",\"1\"]\r\nconst horizontalAxis = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"]\r\n\r\nvar startingPieces: Piece[] = []\r\n\r\nfunction create_start(){\r\n    const pieceArray: Piece[]=[]\r\n    for(var i=0; i<8; i++){\r\n        pieceArray.push({image: \"pieces/Wpawn.png\", rank: \"2\", file: horizontalAxis[i], type: pieceType.PAWN, color: Color.WHITE});\r\n    }\r\n    for(i=0; i<8; i++){\r\n        pieceArray.push({image: \"pieces/Bpawn.png\", rank: \"7\", file: horizontalAxis[i], type: pieceType.PAWN, color: Color.BLACK});\r\n    }\r\n    \r\n    pieceArray.push({image: \"pieces/Wrook.png\", rank: \"1\", file: \"a\", type: pieceType.ROOK, color: Color.WHITE});\r\n    pieceArray.push({image: \"pieces/Wrook.png\", rank: \"1\", file: \"h\", type: pieceType.ROOK, color: Color.WHITE});\r\n    pieceArray.push({image: \"pieces/Brook.png\", rank: \"8\", file: \"a\", type: pieceType.ROOK, color: Color.BLACK});\r\n    pieceArray.push({image: \"pieces/Brook.png\", rank: \"8\", file: \"h\", type: pieceType.ROOK, color: Color.BLACK});\r\n    pieceArray.push({image: \"pieces/Wknight.png\", rank: \"1\", file: \"b\", type: pieceType.KNIGHT, color: Color.WHITE});\r\n    pieceArray.push({image: \"pieces/Wknight.png\", rank: \"1\", file: \"g\", type: pieceType.KNIGHT, color: Color.WHITE});\r\n    pieceArray.push({image: \"pieces/Wbishop.png\", rank: \"1\", file: \"c\", type: pieceType.BISHOP, color: Color.WHITE});\r\n    pieceArray.push({image: \"pieces/Wbishop.png\", rank: \"1\", file: \"f\", type: pieceType.BISHOP, color: Color.WHITE});\r\n    pieceArray.push({image: \"pieces/Bknight.png\", rank: \"8\", file: \"b\", type: pieceType.KNIGHT, color: Color.BLACK});\r\n    pieceArray.push({image: \"pieces/Bknight.png\", rank: \"8\", file: \"g\", type: pieceType.KNIGHT, color: Color.BLACK});\r\n    pieceArray.push({image: \"pieces/Bbishop.png\", rank: \"8\", file: \"c\", type: pieceType.BISHOP, color: Color.BLACK});\r\n    pieceArray.push({image: \"pieces/Bbishop.png\", rank: \"8\", file: \"f\", type: pieceType.BISHOP, color: Color.BLACK});\r\n    pieceArray.push({image: \"pieces/Wqueen.png\", rank: '1', file: \"d\", type: pieceType.QUEEN, color: Color.WHITE});\r\n    pieceArray.push({image: \"pieces/Wking.png\", rank: '1', file: \"e\", type: pieceType.KING, color: Color.WHITE});\r\n    pieceArray.push({image: \"pieces/Bqueen.png\", rank: '8', file: \"d\", type: pieceType.QUEEN, color: Color.BLACK});\r\n    pieceArray.push({image: \"pieces/Bking.png\", rank: '8', file: \"e\", type: pieceType.KING, color: Color.BLACK});\r\n    \r\n    return pieceArray;\r\n}\r\nstartingPieces= create_start();\r\n\r\nvar oldGamePosition: Piece[] = [];\r\nfunction ChessBoardMovesAlready(props: any){\r\n    \r\n    const referee = new gameRef();\r\n    const [pieces, setPieces] = useState<Piece[]>(startingPieces); \r\n    const [turn, setTurn] = useState(0);\r\n    const [userMovesEngine, setUME] = useState<String[]>([])\r\n    const [moveCount, setMoveCount] = useState(0);\r\n    const [takenPieces, setTaken]=useState<TakenPiece[]>([]);\r\n    //props for modal\r\n    const [modalOpen, setModalOpen] =useState(false);\r\n\r\n    function closeModal(){\r\n        setModalOpen(false)\r\n    }\r\n    const movesList = props.movesList\r\n    //says whether or not user moved a piece\r\n    //important for setting board back to old position\r\n    const [playerMoves, setPM] = useState(false);\r\n    //for after player moves set back turn\r\n\r\n    function setMove(moveNum: any){\r\n        setMoveCount(moveNum);\r\n        props.setMove(moveNum);\r\n    }\r\n    //passuser moves to the engine\r\n    useEffect(()=>{\r\n        props.passToEngine(userMovesEngine);\r\n    }, );\r\n    useEffect(()=>{\r\n        gameBeginAudio.play();\r\n        props.passToEngine([]);\r\n    }, [])\r\n    \r\n    const boardRef = useRef<HTMLDivElement>(null);\r\n\r\n    let activePiece: HTMLElement | null = null;\r\n\r\n    const grabPiece = function(event: any){\r\n        const element = event.target;\r\n        //const currSquare = element.parentNode.id;\r\n        const chessboard = boardRef.current;\r\n        if (chessboard){\r\n            let currentRank = verticalAxis[Math.floor((event.clientY- chessboard?.offsetTop) / 94)];\r\n            let currentFile = horizontalAxis[Math.floor((event.clientX - chessboard?.offsetLeft) / 94)];\r\n            let currentPiece = pieces.find(p => p.file===currentFile && p.rank===currentRank);\r\n            if(element.classList.contains(\"chess-piece\")){\r\n                element.style.position=\"absolute\";\r\n                activePiece= element;\r\n            }\r\n        }\r\n    }\r\n    function movePiece(event: any){\r\n        const board = boardRef.current;\r\n        if(activePiece && board){\r\n            const boardSideLeft= board.offsetLeft;\r\n            const boardTop= board.offsetTop;\r\n            const boardSideRight = boardSideLeft + board.clientWidth-70;\r\n            const boardBottom =boardTop + board.clientHeight - 70;\r\n            activePiece.style.position=\"absolute\";\r\n            const  x = event.clientX -47;\r\n            const  y = event.clientY-47;\r\n            //series of if else if keeps piece movement within boards area\r\n            //1st if else if is horizontally and second is vertically\r\n            if( x<boardSideLeft){    \r\n                activePiece.style.left = `${boardSideLeft}px`;\r\n            }else if(x>boardSideRight){\r\n                activePiece.style.left=`${boardSideRight}px`;\r\n            }else{\r\n                activePiece.style.left=`${x}px`;\r\n            }\r\n\r\n            if( y<boardTop){    \r\n                activePiece.style.top = `${boardTop}px`;\r\n            }else if(y>boardBottom){\r\n                activePiece.style.top=`${boardBottom}px`;\r\n            }else{\r\n                activePiece.style.top=`${y}px`;\r\n            }\r\n        }\r\n    }\r\n    function placePiece(event: any){\r\n            const chessboard=boardRef.current;\r\n            \r\n            if(playerMoves===false){\r\n                setPM(true);\r\n                //pushing each piece into a new piece Array\r\n                //it stores the games position before the player moves the pieces. Required to put pieces back\r\n                //newArray=pieces won't work beauase it will not be a pass by reference not pass by value\r\n                pieces.forEach((piece)=>{\r\n                    const oldPiece: Piece = {\r\n                        image: piece.image,\r\n                        rank: piece.rank,\r\n                        file:piece.file,\r\n                        type:piece.type,\r\n                        color:piece.color}\r\n                    oldGamePosition.push(oldPiece);\r\n                })\r\n                \r\n            }\r\n            var validMove = false; //needed to check if a move is okay\r\n\r\n\r\n            \r\n            if(chessboard){\r\n                var newRank = verticalAxis[Math.floor((event.clientY- chessboard?.offsetTop) / 94)];  //this gets the new square based on where I release the mouse\r\n                var newFile = horizontalAxis[Math.floor((event.clientX - chessboard?.offsetLeft) / 94)];\r\n                var newSquare = newFile + newRank;\r\n\r\n\r\n\r\n                const parent=activePiece?.parentElement//needed to get original square. Need square to find the original piece on square\r\n                var currentPiece=pieces.find(p=> (p.file===parent?.id[0] && p.rank===parent.id[1]));\r\n                //var rightTurn = currentPiece?.color===turn; //checks if players turn\r\n\r\n                \r\n                var attackedPiece = pieces.find(p => p.file===newFile && p.rank===newRank);\r\n                if(currentPiece){\r\n                    validMove = referee.isValidMove(parent?.id, newSquare, currentPiece?.type, currentPiece?.color, pieces);\r\n                }\r\n                if(currentPiece?.type===5 && validMove){\r\n                    if(newSquare===\"g1\" && validMove ){\r\n                        castle(\"WK\");\r\n                        setTurn(turn===0?1:0);\r\n\r\n                    }else if(newSquare===\"c1\" && validMove){\r\n                        castle(\"WQ\");\r\n                        setTurn(turn===0?1:0);\r\n\r\n                    }else if(newSquare===\"g8\" && validMove){\r\n                        castle(\"BK\");\r\n                        setTurn(turn===0?1:0);\r\n\r\n                    }else if(newSquare===\"c8\" && validMove){\r\n                        castle(\"BQ\");\r\n                        setTurn(turn===0?1:0);\r\n\r\n                    }\r\n                }\r\n                if(attackedPiece && validMove){\r\n                    //console.log(\"here attacking\")\r\n                    const attackSquare = attackedPiece?.file + attackedPiece.rank;\r\n                    setPieces((value)=>{        \r\n                        const piecesMinusOne = value.reduce((results, piece)=>{\r\n                            const pieceSquare=piece.file + piece.rank;\r\n                            \r\n                            if(pieceSquare!==attackSquare){\r\n                                results.push(piece)\r\n                            }\r\n                            return results\r\n                        }, []as Piece[]);\r\n                        moveSound.play();\r\n\r\n                        return piecesMinusOne;\r\n                    })  \r\n                }\r\n                setPieces((prev)=>{\r\n                    const pieces=prev.map((selectPiece)=>{\r\n                        const parent=activePiece?.parentElement\r\n                        if(validMove && parent&& selectPiece.file===parent.id[0] && selectPiece.rank===parent.id[1]){\r\n                            var moveEngine = parent.id + newSquare;\r\n                            setUME([...userMovesEngine, moveEngine]);\r\n                            //if the moves valid take the piece on current parent square\r\n                            //then give that piece a new rank/ file\r\n                            selectPiece.rank=newRank;\r\n                            selectPiece.file=newFile;\r\n                            setTurn(turn===0?1:0);\r\n                        }else{\r\n                            activePiece?.style.removeProperty(\"top\");\r\n                            activePiece?.style.removeProperty(\"left\");\r\n                            }\r\n                        moveSound.play();\r\n                        return selectPiece;\r\n                    })\r\n                    activePiece=null;\r\n                    return pieces;\r\n                }\r\n                )\r\n               \r\n            \r\n        }\r\n        }\r\n    //Castle function basically moves two pieces the rook and king\r\n    //has to be a seperate function than normal one piece move functin\r\n    function castle(newSquare: string){\r\n        let oldKingSquare =\"\";\r\n        let newKingSquare=\"\";\r\n        let oldRookSquare=\"\";\r\n        let newRookSquare=\"\";\r\n        if(newSquare===\"WK\"){\r\n            oldKingSquare=\"e1\";\r\n            newKingSquare=\"g1\";\r\n            oldRookSquare=\"h1\";\r\n            newRookSquare=\"f1\";\r\n        }else if(newSquare===\"BK\"){\r\n            oldKingSquare=\"e8\";\r\n            newKingSquare=\"g8\";\r\n            oldRookSquare=\"h8\";\r\n            newRookSquare=\"f8\";\r\n        }else if(newSquare===\"BQ\"){\r\n            oldKingSquare=\"e8\";\r\n            newKingSquare=\"c8\";\r\n            oldRookSquare=\"a8\";\r\n            newRookSquare=\"d8\";\r\n        }else if(newSquare===\"WQ\"){\r\n            oldKingSquare=\"e1\";\r\n            newKingSquare=\"c1\";\r\n            oldRookSquare=\"a1\";\r\n            newRookSquare=\"d1\";\r\n        }\r\n        setPieces((prev)=>{\r\n            const pieces=prev.map((selectPiece)=>{\r\n                if(selectPiece.file===oldKingSquare[0] && selectPiece.rank===oldKingSquare[1]){\r\n                    selectPiece.rank=newKingSquare[1];\r\n                    selectPiece.file=newKingSquare[0];\r\n                }else if(selectPiece.file===oldRookSquare[0] && selectPiece.rank===oldRookSquare[1]){\r\n                    selectPiece.rank=newRookSquare[1];\r\n                    selectPiece.file=newRookSquare[0];\r\n                }\r\n                return selectPiece;\r\n            })\r\n            return pieces;\r\n        }\r\n        )\r\n    }\r\n    function castleBack(newSquare: string){\r\n        let oldKingSquare =\"\";\r\n        let newKingSquare=\"\";\r\n        let oldRookSquare=\"\";\r\n        let newRookSquare=\"\"; \r\n        if(newSquare===\"WK\"){\r\n            oldKingSquare=\"g1\";\r\n            newKingSquare=\"e1\";\r\n            oldRookSquare=\"f1\";\r\n            newRookSquare=\"h1\";\r\n        }else if(newSquare===\"BK\"){\r\n            oldKingSquare=\"g8\";\r\n            newKingSquare=\"e8\";\r\n            oldRookSquare=\"f8\";\r\n            newRookSquare=\"h8\";\r\n        }else if(newSquare===\"BQ\"){\r\n            oldKingSquare=\"c8\";\r\n            newKingSquare=\"e8\";\r\n            oldRookSquare=\"d8\";\r\n            newRookSquare=\"a8\";\r\n        }else if(newSquare===\"WQ\"){\r\n            oldKingSquare=\"c1\";\r\n            newKingSquare=\"e1\";\r\n            oldRookSquare=\"d1\";\r\n            newRookSquare=\"a1\";\r\n        }\r\n        setPieces((prev)=>{\r\n            const pieces=prev.map((selectPiece)=>{\r\n                //castle 1st if moves the king and second moves rook\r\n                if(selectPiece.file===oldKingSquare[0] && selectPiece.rank===oldKingSquare[1]){\r\n                    selectPiece.rank=newKingSquare[1];\r\n                    selectPiece.file=newKingSquare[0];\r\n                }else if(selectPiece.file===oldRookSquare[0] && selectPiece.rank===oldRookSquare[1]){\r\n                    selectPiece.rank=newRookSquare[1];\r\n                    selectPiece.file=newRookSquare[0];\r\n                }\r\n                return selectPiece;\r\n            })\r\n            return pieces;\r\n        }\r\n        )\r\n        \r\n    } \r\n\r\n    //called with movewithAn(imation) function below\r\n    function createAnPiece(imgUrl, oldTop, oldLeft, newTop, newLeft){\r\n        const animatedPiece = new MovingImage(imgUrl, oldTop, oldLeft, newTop, newLeft)\r\n        let lastTime=0\r\n        let pieceExists=true\r\n        function update(time){\r\n            if(lastTime!=null && pieceExists===true){\r\n                const delta=time-lastTime\r\n                animatedPiece.update(delta)\r\n\r\n            }\r\n            lastTime=time\r\n            window.requestAnimationFrame(update)\r\n\r\n        }\r\n        if(pieceExists){\r\n            window.requestAnimationFrame(update)\r\n        }\r\n        setTimeout(()=>{\r\n            pieceExists=false;\r\n        }, 300)\r\n    }\r\n    function moveBackWithAn(){\r\n        // if(moveCount<1){\r\n        //     return\r\n        // }\r\n        const move = movesList[moveCount-1]\r\n        if(!move){\r\n            return\r\n        }\r\n        if(move[0]==\"castle\"){\r\n            let m1, m2;\r\n            if(move[1]===\"WK\"){\r\n                m1 = [\"e1\", \"g1\"]\r\n                m2 = [\"h1\", \"f1\"]\r\n            }else if(move[1]==\"WQ\"){\r\n                m1 = [\"e1\", \"c1\"]\r\n                m2 = [\"a1\", \"d1\"]\r\n            }else if(move[1]==\"BK\"){\r\n                m1 = [\"e8\", \"g8\"]\r\n                m2 = [\"h8\", \"f8\"]\r\n            }else{\r\n                m1 = [\"e8\", \"c8\"]\r\n                m2 = [\"a8\", \"d8\"]\r\n            }\r\n            getAnimationInfo(m1, \"backward\")\r\n            getAnimationInfo(m2, \"backward\")\r\n        }else{\r\n            getAnimationInfo(move, \"backward\")\r\n        }\r\n        setTimeout(()=>{\r\n            movePieceBack()\r\n            \r\n        }, 300)\r\n    }\r\n    function getAnimationInfo(move:any, direction:String=\"forward\"){\r\n        let beforeSquare: any;\r\n        let newSquare: any;\r\n        if( direction===\"backward\"  && move){\r\n            const newid= move[0][0] + move[0][1]\r\n            const id=move[1][0] + move[1][1]\r\n            beforeSquare = document.getElementById(id)\r\n            newSquare= document.getElementById(newid)\r\n        }else if(direction==\"forward\" && move){\r\n            const id= move[0][0] + move[0][1]\r\n            const newid=move[1][0] + move[1][1]\r\n            beforeSquare = document.getElementById(id)\r\n            newSquare= document.getElementById(newid)\r\n        }\r\n\r\n        if(beforeSquare && newSquare){\r\n            //console.log(getComputedStyle(beforeSquare).getPropertyValue(\"position\"));\r\n            //square location for animation function\r\n            var rect = beforeSquare.getBoundingClientRect();\r\n            var newRect= newSquare.getBoundingClientRect();\r\n            if(!beforeSquare.getElementsByClassName(\"chess-piece\")[0]){\r\n                return\r\n            }\r\n            //gets image url from intial square. Need for createAnPiece function\r\n            let imgURL=getComputedStyle(beforeSquare.getElementsByClassName(\"chess-piece\")[0])?.getPropertyValue(\"background-image\")\r\n            //this basically hides the current square so that the piece isn't shown twice during movement\r\n            let befMove= beforeSquare.getElementsByClassName(\"chess-piece\")[0]\r\n            befMove.classList.add(\"hideBg\")\r\n            imgURL = imgURL.replace(/^url\\([\"']?/, '').replace(/[\"']?\\)$/, '')\r\n            //console.log(imgURL)\r\n            createAnPiece(imgURL, rect.y, rect.x, newRect.y, newRect.x);\r\n\r\n        }\r\n    }\r\n    function moveWithAn(move: any){\r\n    //move with animation calls the animation of piece\r\n    //waits for animation time: then call move piece game function where react\r\n    //will update stae to re-render pieces on correct square\r\n        if(!move){\r\n            return\r\n        }\r\n        setMove(moveCount+1);            \r\n        \r\n        setTimeout(()=>{\r\n            movePieceGame(move)\r\n  \r\n        }, 300)\r\n        if(move[0]==\"castle\"){\r\n            let m1, m2;\r\n            if(move[1]===\"WK\"){\r\n                m1 = [\"e1\", \"g1\"]\r\n                m2 = [\"h1\", \"f1\"]\r\n            }else if(move[1]==\"WQ\"){\r\n                m1 = [\"e1\", \"c1\"]\r\n                m2 = [\"a1\", \"d1\"]\r\n            }else if(move[1]==\"BK\"){\r\n                m1 = [\"e8\", \"g8\"]\r\n                m2 = [\"h8\", \"f8\"]\r\n            }else{\r\n                m1 = [\"e8\", \"c8\"]\r\n                m2 = [\"a8\", \"d8\"]\r\n            }\r\n            getAnimationInfo(m1)\r\n            getAnimationInfo(m2)\r\n        }else{\r\n            getAnimationInfo(move)\r\n        }\r\n    }\r\n\r\n    function movePieceGame(move: any){\r\n        //set pieces to old game position from saved oldGamePosition variable\r\n        if(playerMoves){\r\n            setPieces(oldGamePosition);\r\n            setPM(false);\r\n            oldGamePosition=[];\r\n            setUME([]);\r\n        }\r\n        moveSound.play()\r\n        //if(movesList[moveCount+1][0]===\"gameOver\"){\r\n\r\n        if(move[0]===\"gameOver\"){\r\n            //end of game. BeforeEnd shows this is the end game modal\r\n            setModalOpen(true);\r\n\r\n        }else if(move[0]===\"castle\"){\r\n            castle(move[1]);\r\n            setTurn(turn===0?1:0);\r\n        }else{\r\n            //regular move not castle or game over\r\n            const chessboard=boardRef.current;\r\n            \r\n            if(chessboard){                \r\n                \r\n                var attackedPiece = pieces.find(p => p.file===move[1][0] && p.rank===move[1][1]);\r\n\r\n                //moveAnimation(move[0], newSquare);\r\n                if(attackedPiece){\r\n                    //console.log(\"here attacking\")\r\n                    var taken:TakenPiece={piece: attackedPiece, moveNumber: moveCount}\r\n                    setTaken(prev=>{\r\n                        return [...prev, taken]\r\n                    });\r\n                    const attackSquare = attackedPiece?.file + attackedPiece.rank;\r\n\r\n                    setPieces((value)=>{        \r\n                        const piecesMinusOne = value.reduce((results, piece)=>{\r\n                            const pieceSquare=piece.file + piece.rank;\r\n                            \r\n                            if(pieceSquare!==attackSquare){\r\n                                results.push(piece)\r\n                            }\r\n                            return results\r\n                        }, []as Piece[]);\r\n                        return piecesMinusOne;\r\n                    })                    \r\n                }\r\n                setPieces((prev)=>{\r\n                    const pieces=prev.map((selectPiece)=>{\r\n                        if(selectPiece.file===move[0][0] && selectPiece.rank===move[0][1]){\r\n                            if(selectPiece.type==0 && ((move[1][1]=='8' && selectPiece.color==0) || (move[1][1]==='1' && selectPiece.color==1))){\r\n                                selectPiece.type=4;\r\n                                selectPiece.image=(\"pieces/Bqueen.png\")\r\n                            }\r\n\r\n                            selectPiece.rank=move[1][1];\r\n                            selectPiece.file=move[1][0];\r\n                            setTurn(turn===0?1:0);\r\n                        }\r\n                        return selectPiece;\r\n                    })\r\n                    return pieces;\r\n                }\r\n                )\r\n            }\r\n        }//else close. else meaning it isn't a castle move\r\n    \r\n    }//movePieceGame close\r\n    //called with backbutton moves back a game move\r\n    function setbackMove(){\r\n        if(moveCount<1){\r\n            return\r\n        }\r\n        setMove(moveCount-1);\r\n        // setTimeout(function(){\r\n        // },200);\r\n    }\r\n    function movePieceBack(){\r\n        const move = movesList[moveCount-1];\r\n        const chessboard=boardRef.current;\r\n        moveSound.play();\r\n        //first checks if user moved pieces from game.\r\n        //same as move forward function\r\n        if(playerMoves){\r\n            setPieces(oldGamePosition);\r\n            setUME([]);\r\n            setPM(false);\r\n            oldGamePosition=[];\r\n        } \r\n        //set the move count back to do the opposite move\r\n        //function is almost the same as forward function but new and old squares flipped\r\n        if(move[0]===\"castle\"){\r\n            castleBack(move[1]);\r\n            setTurn(turn===0?1:0);\r\n\r\n        }else{\r\n            //not reverting a castle or going back from 0. normal  back move    \r\n            if(chessboard){\r\n                setPieces((prev)=>{\r\n                    const pieces=prev.map((selectPiece)=>{\r\n                        if(selectPiece.file===move[1][0] && selectPiece.rank===move[1][1]){\r\n                            selectPiece.rank=move[0][1];\r\n                            selectPiece.file=move[0][0];\r\n                            setTurn(turn===0?1:0);\r\n                        }\r\n                        return selectPiece;\r\n                    })\r\n                    return pieces;\r\n                }\r\n                )\r\n                var tookPiece= takenPieces.find(take=>(take.moveNumber===moveCount-1));\r\n                if (tookPiece){\r\n                    setPieces((prev)=>{\r\n                        return [...prev, tookPiece?.piece];\r\n                    })\r\n                }  \r\n            }      \r\n    }\r\n        }\r\n    \r\n    let board: any=[];\r\n    let counter=0;\r\n    //nested loop to create board w/ black/white squares\r\n    //j is x and i is Y\r\n    \r\n    for(var i=0; i<8; i++){\r\n        for(var j=0; j<8; j++){\r\n            if(j===0){\r\n                counter++;\r\n            }\r\n            let position = horizontalAxis[j] + verticalAxis[i]; \r\n\r\n            let image=\"\";\r\n            pieces.forEach(function(piece){\r\n                //if a pieces position is equal to a square pass that piece into square creation\r\n                //image is either \"\" blank or has the URL of a piece.image\r\n                if(piece.file===position[0] && piece.rank===position[1]){\r\n                    image=piece.image;\r\n                    //return;\r\n                }\r\n            })\r\n            board.push(<Square key={position} number={counter} image={image} sText={position} />);\r\n            counter++;      \r\n        }//ends second for loop\r\n    }//ends first for loop\r\n\r\n    // this function resets the board to starting position and sets move to 0.\r\n    //it's called by the movedisplay component. It .clicks a hidden button \r\n    const resetBoard=()=>{\r\n        const starting = create_start()\r\n        gameBeginAudio.play();\r\n        setPieces(starting)\r\n        setMove(0)\r\n        setPM(false)\r\n        setUME([])\r\n    }\r\n\r\n\r\n    //putting pieces in the squares\r\n\r\n\r\n    \r\n    return(\r\n        <>\r\n        <div className=\"boardDiv\">\r\n        {/* <MoveButton color={buttonClass()} turn={moveTurn}/> */}\r\n\r\n\r\n        <div className=\"chessBoard\"\r\n            onMouseMove={event => movePiece(event)}\r\n            onMouseDown={event => grabPiece(event)}\r\n            onMouseUp={event => placePiece(event)}\r\n            ref={boardRef}>\r\n            {board}\r\n        </div>      \r\n        </div>\r\n        {/* KChad to use arrow function because onclick won't work with type void */}\r\n        <div className=\"belowButtons\">\r\n        <button id=\"backBtn\" className=\"backBtn moveBtn\" onClick={()=>{setbackMove(); moveBackWithAn()}}>Move back</button>\r\n        <button id=\"boardReset\" className=\"moveBtn\" onClick={()=>resetBoard()}>Reset Board</button>\r\n        <button id=\"nextBtn\" className=\"nextBtn moveBtn\" onClick={()=>{moveWithAn(movesList[moveCount])}}>Next Move</button>\r\n        </div>\r\n        <Modal \r\n            show={modalOpen}\r\n            size=\"lg\"\r\n            aria-labelledby=\"contained-modal-title-vcenter\"\r\n            centered\r\n        >\r\n            <GameModal closeModal={setModalOpen} text={props.gameover}/>\r\n        </Modal>\r\n        </>\r\n        )\r\n\r\n}//closes chessboard\r\n\r\nexport default ChessBoardMovesAlready;\r\n\r\nexport {pieceType, Color};\r\n\r\n\r\n","C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\MovesDisplay.tsx",["89"],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Description.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\game\\legalmove.ts",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\square.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Engine.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Accordion.jsx",[],["90","91"],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\Modal.tsx",[],"C:\\Users\\acalo\\Desktop\\devProjects\\ChessFrontDeploy\\src\\components\\MovingImage.js",[],{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","replacedBy":"95"},{"ruleId":"96","severity":1,"message":"97","line":85,"column":14,"nodeType":"98","messageId":"99","endLine":85,"endColumn":24},{"ruleId":"100","severity":1,"message":"101","line":105,"column":8,"nodeType":"102","endLine":105,"endColumn":10,"suggestions":"103"},{"ruleId":"96","severity":1,"message":"104","line":118,"column":17,"nodeType":"98","messageId":"99","endLine":118,"endColumn":29},{"ruleId":"105","severity":1,"message":"106","line":372,"column":19,"nodeType":"107","messageId":"108","endLine":372,"endColumn":21},{"ruleId":"105","severity":1,"message":"106","line":377,"column":29,"nodeType":"107","messageId":"108","endLine":377,"endColumn":31},{"ruleId":"105","severity":1,"message":"106","line":380,"column":29,"nodeType":"107","messageId":"108","endLine":380,"endColumn":31},{"ruleId":"105","severity":1,"message":"106","line":405,"column":27,"nodeType":"107","messageId":"108","endLine":405,"endColumn":29},{"ruleId":"105","severity":1,"message":"106","line":444,"column":19,"nodeType":"107","messageId":"108","endLine":444,"endColumn":21},{"ruleId":"105","severity":1,"message":"106","line":449,"column":29,"nodeType":"107","messageId":"108","endLine":449,"endColumn":31},{"ruleId":"105","severity":1,"message":"106","line":452,"column":29,"nodeType":"107","messageId":"108","endLine":452,"endColumn":31},{"ruleId":"105","severity":1,"message":"106","line":516,"column":48,"nodeType":"107","messageId":"108","endLine":516,"endColumn":50},{"ruleId":"105","severity":1,"message":"106","line":516,"column":67,"nodeType":"107","messageId":"108","endLine":516,"endColumn":69},{"ruleId":"105","severity":1,"message":"106","line":516,"column":93,"nodeType":"107","messageId":"108","endLine":516,"endColumn":95},{"ruleId":"105","severity":1,"message":"106","line":516,"column":139,"nodeType":"107","messageId":"108","endLine":516,"endColumn":141},{"ruleId":"109","severity":1,"message":"110","line":58,"column":63,"nodeType":"111","messageId":"112","endLine":58,"endColumn":65},{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","replacedBy":"95"},"no-native-reassign",["113"],"no-negated-in-lhs",["114"],"@typescript-eslint/no-unused-vars","'closeModal' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.","ArrayExpression",["115"],"'currentPiece' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-global-assign","no-unsafe-negation",{"desc":"116","fix":"117"},"Update the dependencies array to be: [props]",{"range":"118","text":"119"},[4289,4291],"[props]"]